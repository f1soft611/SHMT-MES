# ERP → MES 생산 의뢰 인터페이스 문서

## 개요

이 문서는 ERP 시스템에서 MES 시스템으로 생산 의뢰 정보를 연동하는 인터페이스에 대해 설명합니다.

## 인터페이스 정보

### 연동 방향
**ERP → MES** (단방향)

### 연동 주기
스케쥴러를 통한 주기적 배치 동기화

### 연동 방식
- ERP 데이터베이스에서 생산 의뢰 정보를 조회
- MES 데이터베이스에 INSERT 또는 UPDATE
- 동기화 결과는 SCHEDULER_HISTORY 테이블에 기록

## 테이블 매핑

### ERP 테이블: SHM_IF_VIEW_ProdReq

생산 의뢰 정보를 조회하기 위한 ERP 뷰 테이블

| 컬럼명 | 한글명 | 타입 | 크기 | 설명 |
|--------|--------|------|------|------|
| ProdReqNo | 생산의뢰번호 | NVARCHAR | 100 | 생산 의뢰의 고유 번호 |
| ProdReqSeq | 생산의뢰코드 | int | - | 생산 의뢰의 내부 시퀀스 (PK) |
| Serl | 생산의뢰순번 | int | - | 생산 의뢰의 순번 |
| ReqDate | 생산의뢰일 | nchar | 8 | 생산 의뢰 등록일 (YYYYMMDD) |
| CustSeq | 거래처 | int | - | 거래처 코드 |
| DeptSeq | 의뢰부서 | int | - | 의뢰한 부서 코드 |
| EmpSeq | 의뢰자 | int | - | 의뢰한 사원 코드 |
| ItemSeq | 품목내부코드 | int | - | 품목의 내부 코드 |
| ItemNo | 품목번호 | NVARCHAR | 100 | 품목 번호 |
| ItemName | 품목명 | NVARCHAR | 100 | 품목 이름 |
| Spec | 품목규격 | NVARCHAR | 100 | 품목 규격 |
| UnitSeq | 단위코드 | int | - | 단위 코드 |
| Qty | 의뢰수량 | NUMERIC | 19,5 | 생산 의뢰 수량 |
| EndDate | 완료요청일 | nchar | 8 | 완료 요청 일자 (YYYYMMDD) |
| DelvDate | 납기일 | nchar | 8 | 납품 예정일 (YYYYMMDD) |
| LastUserSeq | 최종수정자내부코드 | int | - | 최종 수정한 사용자 코드 |
| LastDateTime | 최종수정일시 | datetime | - | 최종 수정 일시 |

### MES 테이블: TSA308

생산 의뢰 정보가 저장되는 MES 테이블

| 컬럼명 | 한글명 | 타입 | 크기 | 설명 |
|--------|--------|------|------|------|
| FACTORY_CODE | 공장코드 | varchar | 10 | 공장 식별 코드 (PK) |
| ORDER_NO | 생산의뢰번호 | nvarchar | 200 | 생산 의뢰 번호 |
| ORDER_SEQNO | 생산의뢰코드 | int | 4 | 생산 의뢰 시퀀스 (PK) |
| ORDER_HISTNO | 생산의뢰순번 | int | 4 | 생산 의뢰 순번 |
| ITEM_CODE | 품목내부코드 | varchar | 20 | 품목 코드 |
| ITEM_NO | 품목번호 | nvarchar | 200 | 품목 번호 |
| ITEM_NAME | 품목명 | nvarchar | 200 | 품목명 |
| ITEM_SPEC | 품목규격 | nvarchar | 200 | 품목 규격 |
| ITEM_FLAG | 품목구분 | char | 1 | 품목 구분 플래그 |
| CUSTOMER_CODE | 거래처코드 | varchar | 20 | 거래처 코드 |
| EMPLYR_ID | 의뢰자 | varchar | 50 | 의뢰자 ID |
| ORDER_QTY | 의뢰수량 | real | 4 | 주문 수량 |
| ORDER_PRICE | 단가 | money | 8 | 단가 |
| ORDER_AMOUNT | 금액 | money | 8 | 총 금액 |
| UNIT_CODE | 단위코드 | varchar | 20 | 단위 코드 |
| SHIP_ORDER_QTY | 출하수량 | real | 4 | 출하된 수량 |
| CLOSING_FLAG | 마감여부 | char | 1 | 마감 여부 플래그 |
| DELIVERY_DATE | 납기일 | char | 8 | 납품 예정일 |
| VAT_FLAG | 부가세여부 | char | 1 | 부가세 포함 여부 |
| PROD_PLAN_DATE | 생산계획일 | varchar | 50 | 생산 계획 일자 |
| END_DATE | 완료요청일 | varchar | 8 | 완료 요청 일자 |
| OPMAN_CODE | 작업자코드 | varchar | 20 | 등록자 코드 |
| OPTIME | 작업시간 | datetime2 | 8 | 등록 시간 |
| OPMAN_CODE2 | 수정자코드 | varchar | 20 | 수정자 코드 |
| OPTIME2 | 수정시간 | datetime2 | 8 | 수정 시간 |

### 필드 매핑 규칙

| ERP 필드 | MES 필드 | 변환 규칙 |
|----------|----------|-----------|
| ProdReqNo | ORDER_NO | 직접 매핑 |
| ProdReqSeq | ORDER_SEQNO | 직접 매핑 (PK) |
| Serl | ORDER_HISTNO | 직접 매핑 |
| ItemSeq | ITEM_CODE | 직접 매핑 |
| ItemNo | ITEM_NO | 직접 매핑 |
| ItemName | ITEM_NAME | 직접 매핑 |
| Spec | ITEM_SPEC | 직접 매핑 |
| CustSeq | CUSTOMER_CODE | 직접 매핑 |
| EmpSeq | EMPLYR_ID | 직접 매핑 |
| Qty | ORDER_QTY | 직접 매핑 |
| UnitSeq | UNIT_CODE | 직접 매핑 |
| EndDate | END_DATE | 직접 매핑 (YYYYMMDD) |
| DelvDate | DELIVERY_DATE | 직접 매핑 (YYYYMMDD) |
| ReqDate | PROD_PLAN_DATE | 직접 매핑 |
| - | FACTORY_CODE | 고정값 '000001' |
| - | ITEM_FLAG | 고정값 '0' |
| - | ORDER_PRICE | 고정값 0 |
| - | ORDER_AMOUNT | 고정값 0 |
| - | SHIP_ORDER_QTY | 고정값 0 |
| - | CLOSING_FLAG | 고정값 '0' |
| - | VAT_FLAG | 고정값 '0' |
| - | OPMAN_CODE | 'INTERFACE' (등록시) |
| - | OPTIME | GETDATE() (등록시) |
| - | OPMAN_CODE2 | 'INTERFACE' (수정시) |
| - | OPTIME2 | GETDATE() (수정시) |

## 구현 상세

### 관련 클래스

#### 1. ErpProductionRequest.java
```java
package egovframework.let.scheduler.domain.model;

// ERP 생산 의뢰 정보를 담는 DTO 클래스
// ERP 테이블 구조에 매핑
@Data
public class ErpProductionRequest implements Serializable {
    private String factoryCode;
    private String prodReqNo;
    private Integer prodReqSeq;
    private Integer serl;
    // ... 기타 필드
}
```

#### 2. MesProdReqInterfaceDAO.java
```java
package egovframework.let.scheduler.domain.repository;

// MES 데이터베이스 접근을 위한 DAO
@Repository("mesProdReqInterfaceDAO")
public class MesProdReqInterfaceDAO extends EgovAbstractMapper {
    public int selectMesProdReqCount(Integer prodReqSeq);
    public void insertMesProdReq(ErpProductionRequest prodReq);
    public void updateMesProdReq(ErpProductionRequest prodReq);
}
```

#### 3. ErpToMesInterfaceService.java
```java
// 서비스 인터페이스
public interface ErpToMesInterfaceService {
    void syncProductionRequests() throws Exception;
    void executeProdReqInterface() throws Exception;
}
```

#### 4. ErpToMesInterfaceServiceImpl.java
```java
// 서비스 구현체
@Service("erpToMesInterfaceService")
public class ErpToMesInterfaceServiceImpl implements ErpToMesInterfaceService {
    
    @Override
    @Transactional
    public void syncProductionRequests() throws Exception {
        // ERP에서 데이터 조회
        List<ErpProductionRequest> erpProdReqs = selectErpProductionRequests();
        
        // MES에 동기화 (INSERT or UPDATE)
        for (ErpProductionRequest prodReq : erpProdReqs) {
            int count = mesProdReqInterfaceDAO.selectMesProdReqCount(prodReq.getProdReqSeq());
            if (count == 0) {
                mesProdReqInterfaceDAO.insertMesProdReq(prodReq);
            } else {
                mesProdReqInterfaceDAO.updateMesProdReq(prodReq);
            }
        }
    }
}
```

### MyBatis 매퍼 (MesProdReqInterface_SQL_mssql.xml)

#### 존재 여부 확인
```xml
<select id="selectMesProdReqCount" parameterType="int" resultType="int">
    SELECT COUNT(1) AS cnt
    FROM TSA308
    WHERE FACTORY_CODE = '000001'
      AND ORDER_SEQNO = #{prodReqSeq}
</select>
```

#### 신규 등록
```xml
<insert id="insertMesProdReq" parameterType="...ErpProductionRequest">
    INSERT INTO TSA308 (
        FACTORY_CODE, ORDER_NO, ORDER_SEQNO, ORDER_HISTNO,
        ITEM_CODE, ITEM_NO, ITEM_NAME, ITEM_SPEC, ...
    ) VALUES (
        #{factoryCode}, #{prodReqNo}, #{prodReqSeq}, #{serl},
        #{itemSeq}, #{itemNo}, #{itemName}, #{spec}, ...
    )
</insert>
```

#### 기존 데이터 업데이트
```xml
<update id="updateMesProdReq" parameterType="...ErpProductionRequest">
    UPDATE TSA308
    SET ORDER_NO = #{prodReqNo},
        ITEM_CODE = #{itemSeq},
        ITEM_NAME = #{itemName},
        ...
        OPMAN_CODE2 = 'INTERFACE',
        OPTIME2 = GETDATE()
    WHERE FACTORY_CODE = #{factoryCode}
      AND ORDER_SEQNO = #{prodReqSeq}
</update>
```

## 동기화 프로세스

### 1. 데이터 조회
- ERP의 `SHM_IF_VIEW_ProdReq` 뷰에서 생산 의뢰 정보 조회
- `ProdReqSeq`, `Serl` 순으로 정렬

### 2. 데이터 처리
각 생산 의뢰 정보에 대해:
1. MES의 TSA308 테이블에서 해당 생산 의뢰 존재 여부 확인 (ORDER_SEQNO 기준)
2. 존재하지 않으면 INSERT
3. 존재하면 UPDATE

### 3. 결과 기록
- 처리 건수 (총 처리, 신규 등록, 업데이트, 오류)
- 실행 시간
- 오류 메시지 (있는 경우)

## 스케쥴러 설정

### 스케쥴러 등록 예시

```sql
INSERT INTO SCHEDULER_CONFIG (
    SCHEDULER_NAME,
    SCHEDULER_DESCRIPTION,
    CRON_EXPRESSION,
    JOB_CLASS_NAME,
    IS_ENABLED,
    REG_USER_ID
) VALUES (
    'ERP_MES_PROD_REQ_SYNC',
    'ERP 생산 의뢰 정보 MES 동기화',
    '0 */30 * * * ?',  -- 30분마다 실행
    'egovframework.let.scheduler.job.ErpProdReqSyncJob',
    'Y',
    'SYSTEM'
);
```

### Cron 표현식 예시

| 표현식 | 설명 |
|--------|------|
| `0 0 * * * ?` | 매 시간 정각 |
| `0 */30 * * * ?` | 30분마다 |
| `0 0 9-18 * * ?` | 평일 9시~18시 매 시간 |
| `0 0 0 * * ?` | 매일 자정 |

## 오류 처리

### 오류 발생 시 동작
1. 개별 생산 의뢰 처리 중 오류 발생 → 해당 건만 스킵하고 다음 건 처리
2. 오류 카운트 및 마지막 오류 기록
3. 전체 처리 완료 후 오류가 있으면 예외 발생
4. 스케쥴러 히스토리에 실패로 기록

### 로그 레벨
- **INFO**: 동기화 시작/종료, 처리 결과 요약
- **DEBUG**: 개별 생산 의뢰 처리 내역
- **ERROR**: 오류 발생 상세 정보

## 모니터링

### 확인 방법

#### 1. 스케쥴러 실행 이력 조회
```sql
SELECT 
    h.HISTORY_ID,
    h.SCHEDULER_NAME,
    h.START_TIME,
    h.END_TIME,
    h.STATUS,
    h.EXECUTION_TIME_MS,
    h.ERROR_MESSAGE
FROM SCHEDULER_HISTORY h
WHERE h.SCHEDULER_NAME = 'ERP_MES_PROD_REQ_SYNC'
ORDER BY h.START_TIME DESC;
```

#### 2. 최근 동기화된 생산 의뢰 확인
```sql
SELECT 
    FACTORY_CODE,
    ORDER_NO,
    ORDER_SEQNO,
    ITEM_NAME,
    ORDER_QTY,
    DELIVERY_DATE,
    OPTIME
FROM TSA308
WHERE OPMAN_CODE = 'INTERFACE'
ORDER BY OPTIME DESC;
```

#### 3. 동기화 실패 건 확인
```sql
SELECT 
    h.SCHEDULER_NAME,
    h.START_TIME,
    h.ERROR_MESSAGE
FROM SCHEDULER_HISTORY h
WHERE h.SCHEDULER_NAME = 'ERP_MES_PROD_REQ_SYNC'
  AND h.STATUS = 'FAILED'
ORDER BY h.START_TIME DESC;
```

## 주의사항

### 데이터 정합성
- ERP의 품목 코드, 거래처 코드, 사원 코드가 MES에 사전 등록되어 있어야 함
- 날짜 형식은 YYYYMMDD (8자리) 형식 사용

### 성능 고려사항
- 대량 데이터 처리 시 배치 크기 조절 고려
- 인덱스 활용: ORDER_SEQNO, ORDER_NO, ITEM_CODE, CUSTOMER_CODE

### 트랜잭션
- 전체 동기화는 하나의 트랜잭션으로 처리
- 오류 발생 시 롤백 정책 확인 필요

## 관련 문서
- [스케쥴러 설정 가이드](../백엔드_개발_가이드.md)
- [인터페이스 보안 정책](./README.md)
